// Code generated by protoc-gen-go. DO NOT EDIT.
// source: tokenstore.proto

/*
Package tokenstore is a generated protocol buffer package.

It is generated from these files:
	tokenstore.proto

It has these top-level messages:
	Token
	Tokens
	TokenMsg
	TokenStatusMsg
	TokenPeriodRequest
	UsageTimes
	UserRequest
	RpcStatus
	RpcRequest
	Validity
*/
package tokenstore

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Token is a message containing the ID.
type Token struct {
	Id      string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Service string `protobuf:"bytes,2,opt,name=service" json:"service,omitempty"`
}

func (m *Token) Reset()                    { *m = Token{} }
func (m *Token) String() string            { return proto.CompactTextString(m) }
func (*Token) ProtoMessage()               {}
func (*Token) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Token) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Token) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

// Tokens is a message containing multiple IDs
type Tokens struct {
	Ids      []string `protobuf:"bytes,1,rep,name=ids" json:"ids,omitempty"`
	Services []string `protobuf:"bytes,2,rep,name=services" json:"services,omitempty"`
}

func (m *Tokens) Reset()                    { *m = Tokens{} }
func (m *Tokens) String() string            { return proto.CompactTextString(m) }
func (*Tokens) ProtoMessage()               {}
func (*Tokens) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Tokens) GetIds() []string {
	if m != nil {
		return m.Ids
	}
	return nil
}

func (m *Tokens) GetServices() []string {
	if m != nil {
		return m.Services
	}
	return nil
}

// TokenMsg contains token ID and limit.
type TokenMsg struct {
	Id      string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Limit   int32  `protobuf:"varint,2,opt,name=limit" json:"limit,omitempty"`
	Usage   int32  `protobuf:"varint,3,opt,name=usage" json:"usage,omitempty"`
	User    string `protobuf:"bytes,4,opt,name=user" json:"user,omitempty"`
	Service string `protobuf:"bytes,5,opt,name=service" json:"service,omitempty"`
	Rate    int32  `protobuf:"varint,6,opt,name=rate" json:"rate,omitempty"`
}

func (m *TokenMsg) Reset()                    { *m = TokenMsg{} }
func (m *TokenMsg) String() string            { return proto.CompactTextString(m) }
func (*TokenMsg) ProtoMessage()               {}
func (*TokenMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *TokenMsg) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TokenMsg) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *TokenMsg) GetUsage() int32 {
	if m != nil {
		return m.Usage
	}
	return 0
}

func (m *TokenMsg) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *TokenMsg) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

func (m *TokenMsg) GetRate() int32 {
	if m != nil {
		return m.Rate
	}
	return 0
}

// TokenStatusMsg contains token ID, limit, and current usage.
type TokenStatusMsg struct {
	Id      string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Limit   int32  `protobuf:"varint,2,opt,name=limit" json:"limit,omitempty"`
	Usage   int32  `protobuf:"varint,3,opt,name=usage" json:"usage,omitempty"`
	Allowed bool   `protobuf:"varint,4,opt,name=allowed" json:"allowed,omitempty"`
}

func (m *TokenStatusMsg) Reset()                    { *m = TokenStatusMsg{} }
func (m *TokenStatusMsg) String() string            { return proto.CompactTextString(m) }
func (*TokenStatusMsg) ProtoMessage()               {}
func (*TokenStatusMsg) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *TokenStatusMsg) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TokenStatusMsg) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *TokenStatusMsg) GetUsage() int32 {
	if m != nil {
		return m.Usage
	}
	return 0
}

func (m *TokenStatusMsg) GetAllowed() bool {
	if m != nil {
		return m.Allowed
	}
	return false
}

// TokenPeriodRequest contains the start and end times
// for the token of interest.
type TokenPeriodRequest struct {
	Id    string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Start int64  `protobuf:"varint,2,opt,name=start" json:"start,omitempty"`
	End   int64  `protobuf:"varint,3,opt,name=end" json:"end,omitempty"`
}

func (m *TokenPeriodRequest) Reset()                    { *m = TokenPeriodRequest{} }
func (m *TokenPeriodRequest) String() string            { return proto.CompactTextString(m) }
func (*TokenPeriodRequest) ProtoMessage()               {}
func (*TokenPeriodRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *TokenPeriodRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TokenPeriodRequest) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *TokenPeriodRequest) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

// UsageTimes contains the Unix times of when the token was used.
type UsageTimes struct {
	Times []int64 `protobuf:"varint,1,rep,packed,name=times" json:"times,omitempty"`
}

func (m *UsageTimes) Reset()                    { *m = UsageTimes{} }
func (m *UsageTimes) String() string            { return proto.CompactTextString(m) }
func (*UsageTimes) ProtoMessage()               {}
func (*UsageTimes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *UsageTimes) GetTimes() []int64 {
	if m != nil {
		return m.Times
	}
	return nil
}

// UserRequest contains user ID and optional service name.
type UserRequest struct {
	User    string `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
	Service string `protobuf:"bytes,2,opt,name=service" json:"service,omitempty"`
}

func (m *UserRequest) Reset()                    { *m = UserRequest{} }
func (m *UserRequest) String() string            { return proto.CompactTextString(m) }
func (*UserRequest) ProtoMessage()               {}
func (*UserRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *UserRequest) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *UserRequest) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

// generic rpc call status
type RpcStatus struct {
	Success bool `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
}

func (m *RpcStatus) Reset()                    { *m = RpcStatus{} }
func (m *RpcStatus) String() string            { return proto.CompactTextString(m) }
func (*RpcStatus) ProtoMessage()               {}
func (*RpcStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *RpcStatus) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

// generic rpc request
type RpcRequest struct {
	Do bool `protobuf:"varint,1,opt,name=do" json:"do,omitempty"`
}

func (m *RpcRequest) Reset()                    { *m = RpcRequest{} }
func (m *RpcRequest) String() string            { return proto.CompactTextString(m) }
func (*RpcRequest) ProtoMessage()               {}
func (*RpcRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *RpcRequest) GetDo() bool {
	if m != nil {
		return m.Do
	}
	return false
}

// Validity will return true if token is valid, false if not
type Validity struct {
	Valid bool `protobuf:"varint,1,opt,name=valid" json:"valid,omitempty"`
}

func (m *Validity) Reset()                    { *m = Validity{} }
func (m *Validity) String() string            { return proto.CompactTextString(m) }
func (*Validity) ProtoMessage()               {}
func (*Validity) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Validity) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func init() {
	proto.RegisterType((*Token)(nil), "tokenstore.Token")
	proto.RegisterType((*Tokens)(nil), "tokenstore.Tokens")
	proto.RegisterType((*TokenMsg)(nil), "tokenstore.TokenMsg")
	proto.RegisterType((*TokenStatusMsg)(nil), "tokenstore.TokenStatusMsg")
	proto.RegisterType((*TokenPeriodRequest)(nil), "tokenstore.TokenPeriodRequest")
	proto.RegisterType((*UsageTimes)(nil), "tokenstore.UsageTimes")
	proto.RegisterType((*UserRequest)(nil), "tokenstore.UserRequest")
	proto.RegisterType((*RpcStatus)(nil), "tokenstore.RpcStatus")
	proto.RegisterType((*RpcRequest)(nil), "tokenstore.RpcRequest")
	proto.RegisterType((*Validity)(nil), "tokenstore.Validity")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for TokenStore service

type TokenStoreClient interface {
	// add token to redis
	AddToken(ctx context.Context, in *TokenMsg, opts ...grpc.CallOption) (*RpcStatus, error)
	// regenerate existing token
	RegenToken(ctx context.Context, in *TokenMsg, opts ...grpc.CallOption) (*RpcStatus, error)
	// update limit on token
	UpdateLimit(ctx context.Context, in *TokenMsg, opts ...grpc.CallOption) (*RpcStatus, error)
	// update usage on token
	UpdateUsage(ctx context.Context, in *TokenMsg, opts ...grpc.CallOption) (*RpcStatus, error)
	// token status with limit and current usage
	TokenStatus(ctx context.Context, in *Token, opts ...grpc.CallOption) (*TokenStatusMsg, error)
	// increment the token current usage
	IncUsage(ctx context.Context, in *Token, opts ...grpc.CallOption) (*RpcStatus, error)
	// delete token
	DelToken(ctx context.Context, in *TokenMsg, opts ...grpc.CallOption) (*RpcStatus, error)
	// get all tokens
	GetAllTokens(ctx context.Context, in *RpcRequest, opts ...grpc.CallOption) (*Tokens, error)
	// token usage by time
	GetUsageTimes(ctx context.Context, in *TokenPeriodRequest, opts ...grpc.CallOption) (*UsageTimes, error)
	// tokens for given user
	GetUserTokens(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*Tokens, error)
}

type tokenStoreClient struct {
	cc *grpc.ClientConn
}

func NewTokenStoreClient(cc *grpc.ClientConn) TokenStoreClient {
	return &tokenStoreClient{cc}
}

func (c *tokenStoreClient) AddToken(ctx context.Context, in *TokenMsg, opts ...grpc.CallOption) (*RpcStatus, error) {
	out := new(RpcStatus)
	err := grpc.Invoke(ctx, "/tokenstore.TokenStore/AddToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenStoreClient) RegenToken(ctx context.Context, in *TokenMsg, opts ...grpc.CallOption) (*RpcStatus, error) {
	out := new(RpcStatus)
	err := grpc.Invoke(ctx, "/tokenstore.TokenStore/RegenToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenStoreClient) UpdateLimit(ctx context.Context, in *TokenMsg, opts ...grpc.CallOption) (*RpcStatus, error) {
	out := new(RpcStatus)
	err := grpc.Invoke(ctx, "/tokenstore.TokenStore/UpdateLimit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenStoreClient) UpdateUsage(ctx context.Context, in *TokenMsg, opts ...grpc.CallOption) (*RpcStatus, error) {
	out := new(RpcStatus)
	err := grpc.Invoke(ctx, "/tokenstore.TokenStore/UpdateUsage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenStoreClient) TokenStatus(ctx context.Context, in *Token, opts ...grpc.CallOption) (*TokenStatusMsg, error) {
	out := new(TokenStatusMsg)
	err := grpc.Invoke(ctx, "/tokenstore.TokenStore/TokenStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenStoreClient) IncUsage(ctx context.Context, in *Token, opts ...grpc.CallOption) (*RpcStatus, error) {
	out := new(RpcStatus)
	err := grpc.Invoke(ctx, "/tokenstore.TokenStore/IncUsage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenStoreClient) DelToken(ctx context.Context, in *TokenMsg, opts ...grpc.CallOption) (*RpcStatus, error) {
	out := new(RpcStatus)
	err := grpc.Invoke(ctx, "/tokenstore.TokenStore/DelToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenStoreClient) GetAllTokens(ctx context.Context, in *RpcRequest, opts ...grpc.CallOption) (*Tokens, error) {
	out := new(Tokens)
	err := grpc.Invoke(ctx, "/tokenstore.TokenStore/GetAllTokens", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenStoreClient) GetUsageTimes(ctx context.Context, in *TokenPeriodRequest, opts ...grpc.CallOption) (*UsageTimes, error) {
	out := new(UsageTimes)
	err := grpc.Invoke(ctx, "/tokenstore.TokenStore/GetUsageTimes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenStoreClient) GetUserTokens(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*Tokens, error) {
	out := new(Tokens)
	err := grpc.Invoke(ctx, "/tokenstore.TokenStore/GetUserTokens", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TokenStore service

type TokenStoreServer interface {
	// add token to redis
	AddToken(context.Context, *TokenMsg) (*RpcStatus, error)
	// regenerate existing token
	RegenToken(context.Context, *TokenMsg) (*RpcStatus, error)
	// update limit on token
	UpdateLimit(context.Context, *TokenMsg) (*RpcStatus, error)
	// update usage on token
	UpdateUsage(context.Context, *TokenMsg) (*RpcStatus, error)
	// token status with limit and current usage
	TokenStatus(context.Context, *Token) (*TokenStatusMsg, error)
	// increment the token current usage
	IncUsage(context.Context, *Token) (*RpcStatus, error)
	// delete token
	DelToken(context.Context, *TokenMsg) (*RpcStatus, error)
	// get all tokens
	GetAllTokens(context.Context, *RpcRequest) (*Tokens, error)
	// token usage by time
	GetUsageTimes(context.Context, *TokenPeriodRequest) (*UsageTimes, error)
	// tokens for given user
	GetUserTokens(context.Context, *UserRequest) (*Tokens, error)
}

func RegisterTokenStoreServer(s *grpc.Server, srv TokenStoreServer) {
	s.RegisterService(&_TokenStore_serviceDesc, srv)
}

func _TokenStore_AddToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenStoreServer).AddToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tokenstore.TokenStore/AddToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenStoreServer).AddToken(ctx, req.(*TokenMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenStore_RegenToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenStoreServer).RegenToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tokenstore.TokenStore/RegenToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenStoreServer).RegenToken(ctx, req.(*TokenMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenStore_UpdateLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenStoreServer).UpdateLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tokenstore.TokenStore/UpdateLimit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenStoreServer).UpdateLimit(ctx, req.(*TokenMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenStore_UpdateUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenStoreServer).UpdateUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tokenstore.TokenStore/UpdateUsage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenStoreServer).UpdateUsage(ctx, req.(*TokenMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenStore_TokenStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Token)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenStoreServer).TokenStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tokenstore.TokenStore/TokenStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenStoreServer).TokenStatus(ctx, req.(*Token))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenStore_IncUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Token)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenStoreServer).IncUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tokenstore.TokenStore/IncUsage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenStoreServer).IncUsage(ctx, req.(*Token))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenStore_DelToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenStoreServer).DelToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tokenstore.TokenStore/DelToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenStoreServer).DelToken(ctx, req.(*TokenMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenStore_GetAllTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenStoreServer).GetAllTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tokenstore.TokenStore/GetAllTokens",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenStoreServer).GetAllTokens(ctx, req.(*RpcRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenStore_GetUsageTimes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenPeriodRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenStoreServer).GetUsageTimes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tokenstore.TokenStore/GetUsageTimes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenStoreServer).GetUsageTimes(ctx, req.(*TokenPeriodRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenStore_GetUserTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenStoreServer).GetUserTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tokenstore.TokenStore/GetUserTokens",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenStoreServer).GetUserTokens(ctx, req.(*UserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TokenStore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tokenstore.TokenStore",
	HandlerType: (*TokenStoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddToken",
			Handler:    _TokenStore_AddToken_Handler,
		},
		{
			MethodName: "RegenToken",
			Handler:    _TokenStore_RegenToken_Handler,
		},
		{
			MethodName: "UpdateLimit",
			Handler:    _TokenStore_UpdateLimit_Handler,
		},
		{
			MethodName: "UpdateUsage",
			Handler:    _TokenStore_UpdateUsage_Handler,
		},
		{
			MethodName: "TokenStatus",
			Handler:    _TokenStore_TokenStatus_Handler,
		},
		{
			MethodName: "IncUsage",
			Handler:    _TokenStore_IncUsage_Handler,
		},
		{
			MethodName: "DelToken",
			Handler:    _TokenStore_DelToken_Handler,
		},
		{
			MethodName: "GetAllTokens",
			Handler:    _TokenStore_GetAllTokens_Handler,
		},
		{
			MethodName: "GetUsageTimes",
			Handler:    _TokenStore_GetUsageTimes_Handler,
		},
		{
			MethodName: "GetUserTokens",
			Handler:    _TokenStore_GetUserTokens_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tokenstore.proto",
}

// Client API for TSDaemon service

type TSDaemonClient interface {
	// check if token is valid
	CheckValidity(ctx context.Context, in *Token, opts ...grpc.CallOption) (*Validity, error)
}

type tSDaemonClient struct {
	cc *grpc.ClientConn
}

func NewTSDaemonClient(cc *grpc.ClientConn) TSDaemonClient {
	return &tSDaemonClient{cc}
}

func (c *tSDaemonClient) CheckValidity(ctx context.Context, in *Token, opts ...grpc.CallOption) (*Validity, error) {
	out := new(Validity)
	err := grpc.Invoke(ctx, "/tokenstore.TSDaemon/CheckValidity", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TSDaemon service

type TSDaemonServer interface {
	// check if token is valid
	CheckValidity(context.Context, *Token) (*Validity, error)
}

func RegisterTSDaemonServer(s *grpc.Server, srv TSDaemonServer) {
	s.RegisterService(&_TSDaemon_serviceDesc, srv)
}

func _TSDaemon_CheckValidity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Token)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TSDaemonServer).CheckValidity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tokenstore.TSDaemon/CheckValidity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TSDaemonServer).CheckValidity(ctx, req.(*Token))
	}
	return interceptor(ctx, in, info, handler)
}

var _TSDaemon_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tokenstore.TSDaemon",
	HandlerType: (*TSDaemonServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckValidity",
			Handler:    _TSDaemon_CheckValidity_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tokenstore.proto",
}

func init() { proto.RegisterFile("tokenstore.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 550 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x54, 0x51, 0x6f, 0xd3, 0x3c,
	0x14, 0x6d, 0x92, 0xb6, 0x4b, 0x6f, 0xbf, 0xed, 0x1b, 0xd6, 0x06, 0x51, 0x84, 0x50, 0x65, 0x09,
	0x69, 0x4f, 0x15, 0x0c, 0x69, 0xd2, 0x18, 0x42, 0xda, 0x98, 0x98, 0x26, 0x86, 0x54, 0xb9, 0x2d,
	0xef, 0x21, 0xbe, 0x2b, 0xd1, 0xd2, 0xba, 0xd8, 0xee, 0x10, 0xff, 0x80, 0xdf, 0xc1, 0xef, 0xe4,
	0x01, 0xd9, 0x4e, 0xda, 0x74, 0x0d, 0x0f, 0x94, 0xb7, 0x7b, 0x6e, 0xef, 0xf1, 0xb9, 0x3d, 0x3e,
	0x31, 0xec, 0x6b, 0x71, 0x87, 0x33, 0xa5, 0x85, 0xc4, 0xfe, 0x5c, 0x0a, 0x2d, 0x08, 0xac, 0x3a,
	0xf4, 0x25, 0xb4, 0x46, 0x06, 0x91, 0x3d, 0xf0, 0x33, 0x1e, 0x79, 0x3d, 0xef, 0xa8, 0xc3, 0xfc,
	0x8c, 0x93, 0x08, 0x76, 0x14, 0xca, 0xfb, 0x2c, 0xc5, 0xc8, 0xb7, 0xcd, 0x12, 0xd2, 0x13, 0x68,
	0x5b, 0x8a, 0x22, 0xfb, 0x10, 0x64, 0x5c, 0x45, 0x5e, 0x2f, 0x38, 0xea, 0x30, 0x53, 0x92, 0x18,
	0xc2, 0x62, 0x4c, 0x45, 0xbe, 0x6d, 0x2f, 0x31, 0xfd, 0xe1, 0x41, 0x68, 0x89, 0x1f, 0xd5, 0x64,
	0x43, 0xee, 0x00, 0x5a, 0x79, 0x36, 0xcd, 0xb4, 0x15, 0x6b, 0x31, 0x07, 0x4c, 0x77, 0xa1, 0x92,
	0x09, 0x46, 0x81, 0xeb, 0x5a, 0x40, 0x08, 0x34, 0x17, 0x0a, 0x65, 0xd4, 0xb4, 0x6c, 0x5b, 0x57,
	0xd7, 0x6d, 0xad, 0xad, 0x6b, 0xa6, 0x65, 0xa2, 0x31, 0x6a, 0xdb, 0x23, 0x6c, 0x4d, 0x6f, 0x61,
	0xcf, 0x6e, 0x32, 0xd4, 0x89, 0x5e, 0xa8, 0x7f, 0xdd, 0x27, 0x82, 0x9d, 0x24, 0xcf, 0xc5, 0x37,
	0xe4, 0x76, 0xa5, 0x90, 0x95, 0x90, 0xde, 0x00, 0xb1, 0x3a, 0x03, 0x94, 0x99, 0xe0, 0x0c, 0xbf,
	0x2e, 0x50, 0xe9, 0x3a, 0x2d, 0xa5, 0x13, 0xe9, 0xb4, 0x02, 0xe6, 0x80, 0x31, 0x17, 0x67, 0xdc,
	0x2a, 0x05, 0xcc, 0x94, 0x94, 0x02, 0x8c, 0x8d, 0xe0, 0x28, 0x9b, 0xa2, 0x32, 0x2c, 0x6d, 0x0a,
	0x6b, 0x7f, 0xc0, 0x1c, 0xa0, 0x67, 0xd0, 0x1d, 0x2b, 0x94, 0xa5, 0x54, 0x69, 0x95, 0x57, 0x6f,
	0xd5, 0x83, 0x9b, 0x7d, 0x0e, 0x1d, 0x36, 0x4f, 0x9d, 0x29, 0x76, 0x6c, 0x91, 0xa6, 0xa8, 0x94,
	0x65, 0x87, 0xac, 0x84, 0xf4, 0x29, 0x00, 0x9b, 0xa7, 0x95, 0x7f, 0xc3, 0x45, 0x31, 0xe2, 0x73,
	0x41, 0x7b, 0x10, 0x7e, 0x4a, 0xf2, 0x8c, 0x67, 0xfa, 0xbb, 0xd9, 0xf1, 0xde, 0xd4, 0xc5, 0xcf,
	0x0e, 0x1c, 0xff, 0x6a, 0x02, 0x14, 0xf6, 0x0b, 0x89, 0xe4, 0x14, 0xc2, 0x73, 0xce, 0x5d, 0x0a,
	0x0f, 0xfa, 0x95, 0xb4, 0x96, 0x61, 0x89, 0x0f, 0xab, 0xdd, 0xe5, 0x86, 0xb4, 0x41, 0xce, 0x00,
	0x18, 0x4e, 0x70, 0xb6, 0x15, 0xf9, 0x0d, 0x74, 0xc7, 0x73, 0x9e, 0x68, 0xbc, 0x71, 0x77, 0xbb,
	0x25, 0xdb, 0x5e, 0xc9, 0xdf, 0xb2, 0xdf, 0x42, 0xb7, 0x12, 0x40, 0xf2, 0x68, 0x83, 0x1d, 0xc7,
	0x1b, 0xad, 0x65, 0x58, 0x69, 0x83, 0x9c, 0x40, 0x78, 0x3d, 0x4b, 0x9d, 0x74, 0x0d, 0xf9, 0x8f,
	0xba, 0xa7, 0x10, 0x5e, 0x62, 0xbe, 0xa5, 0x5d, 0xff, 0x5d, 0xa1, 0x3e, 0xcf, 0xf3, 0xe2, 0xe3,
	0x7f, 0xfc, 0x60, 0xb0, 0xc8, 0x43, 0x4c, 0x36, 0x8e, 0x35, 0xec, 0x6b, 0xd8, 0xbd, 0x42, 0x5d,
	0x89, 0xef, 0xb3, 0x8d, 0xb1, 0xb5, 0x8f, 0x24, 0x5e, 0x3b, 0x7e, 0xc5, 0xb3, 0xde, 0xb9, 0xa3,
	0x50, 0x16, 0x9b, 0x3c, 0x59, 0x1f, 0x5d, 0xa6, 0xbf, 0x7e, 0x95, 0xe3, 0xf7, 0x10, 0x8e, 0x86,
	0x97, 0x09, 0x4e, 0xc5, 0x8c, 0xbc, 0x86, 0xdd, 0x77, 0x5f, 0x30, 0xbd, 0x5b, 0x26, 0xb6, 0xc6,
	0xcc, 0x35, 0x9f, 0xca, 0x41, 0xda, 0xb8, 0x78, 0x01, 0x87, 0xa9, 0x98, 0xf6, 0x55, 0xa2, 0xfa,
	0xb7, 0x58, 0x99, 0xb9, 0xf8, 0x7f, 0x15, 0xee, 0x81, 0x79, 0x70, 0x07, 0xde, 0x4f, 0x3f, 0x18,
	0x7d, 0x18, 0x7e, 0x6e, 0xdb, 0xf7, 0xf7, 0xd5, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0xfc, 0xb8,
	0x55, 0xba, 0x93, 0x05, 0x00, 0x00,
}
